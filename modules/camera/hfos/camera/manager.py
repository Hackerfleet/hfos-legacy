"""


Module: CameraManager
=====================

:copyright: (C) 2011-2016 riot@c-base.org
:license: GPLv3 (See LICENSE)

"""

from uuid import uuid4
from circuits import Timer, Event
from circuits.tools import tryimport
import six
from hfos.component import ConfigurableComponent, authorizedevent, handler
from hfos.events.client import send
from hfos.logger import error, debug

__author__ = "Heiko 'riot' Weinen <riot@c-base.org>"

opencv = tryimport("cv2")


# Camera requests


class camera_list(authorizedevent):
    """A new camera event has been generated by the client"""


class camera_subscribe(authorizedevent):
    """A new camera event has been generated by the client"""


class camera_unsubscribe(authorizedevent):
    """A new camera event has been generated by the client"""


class Manager(ConfigurableComponent):
    """
    Handles camera updates, subscriptions and broadcasts
    """

    channel = "cam"

    def __init__(self, maxcams=16, *args):
        super(Manager, self).__init__("CAM", *args)

        self._cameras = {}
        self._subscribers = {}
        self._filming = True
        self._frame_count = 0
        self._frames = {}

        if opencv is not None:
            self.log("Checking opencv for cameras.", lvl=debug)

            for cam in range(maxcams):
                video = opencv.VideoCapture(cam)
                if video.isOpened():
                    camera = {'uuid': str(uuid4()),
                              'name': 'Camera' + str(cam),
                              'cam': video
                              }
                    self._cameras[cam] = camera
                    self.log("Found camera [", cam, "]: ", camera)

            if len(self._cameras) > 0:
                self.log("Starting timer")
                self.timer = Timer(0.05, Event.create("rec"),
                                   persist=True).register(self)

            self.log("Found cameras: ", self._cameras, lvl=debug)
        else:
            self.log("No opencv, no cameras.")

        self.log("Started")

    def rec(self):
        """Records a single snapshot"""

        try:
            self._snapshot()
        except Exception as e:
            self.log("Timer error: ", e, type(e), lvl=error)

    def _snapshot(self):
        try:
            for cam_id, cam in self._cameras.items():
                if cam['uuid'] in self._subscribers:
                    # self.log("Taking input of ", cam)
                    success, cvresult = cam['cam'].read()
                    # self.log("Result: ", cvresult)
                    if success:

                        cam_packet_header = {
                            'component': 'hfos.camera.manager' + str(
                                cam_id),
                            'action': 'update'
                        }
                        if six.PY3:
                            # noinspection PyArgumentList
                            cam_packet = bytes(str(cam_packet_header),
                                               encoding="UTF8") + \
                                         cvresult.tostring()
                        else:
                            cam_packet = bytes(
                                str(cam_packet_header)) + cvresult.tostring()

                        self._broadcast(cam_packet, cam['uuid'])
                    else:
                        self.log("Failed to get an image.", success, cvresult)
                    self._frame_count += 1

            if self._frame_count > 0 and self._frame_count % 100 == 0:
                self.log("", self._frame_count, " frames taken.", lvl=debug)

        except Exception as e:
            self.log("Error: ", e, type(e), lvl=error)

    def _toggle_filming(self):
        """Toggles the camera system recording state"""

        if self._filming:
            self.log("Stopping operation")
            self._filming = False
            self.timer.stop()
        else:
            self.log("Starting operation")
            self._filming = True
            self.timer.start()

    def _broadcast(self, camera_packet, camera_uuid):
        try:
            for recipient in self._subscribers[camera_uuid]:
                self.fireEvent(send(recipient, camera_packet, raw=True),
                               "hfosweb")
        except Exception as e:
            self.log("Failed broadcast: ", e, type(e), lvl=error)

    def _generate_camera_list(self):
        try:
            result = {}
            for item in self._cameras.values():
                result[item['name']] = item['uuid']
            return result
        except Exception as e:
            self.log("Error during list retrieval:", e, type(e), lvl=error)

    def _unsubscribe(self, client_uuid, camera_uuid=None):
        # TODO: Verify everything and send a response
        if not camera_uuid:
            for subscribers in self._subscribers.values():
                if client_uuid in subscribers:
                    subscribers.remove(client_uuid)
                    self.log("Subscription removed: ", client_uuid, lvl=debug)
        else:
            self._subscribers[camera_uuid].remove(client_uuid)
            if len(self._subscribers[camera_uuid]) == 0:
                del (self._subscribers[camera_uuid])
                self.log("Subscription deleted: ", camera_uuid, client_uuid)

    def client_disconnect(self, event):
        """
        A client has disconnected, update possible subscriptions accordingly.

        :param event:
        """
        self.log("Removing disconnected client from subscriptions", lvl=debug)
        client_uuid = event.clientuuid
        self._unsubscribe(client_uuid)

    @handler(camera_list, channel='hfosweb')
    def camera_list(self, event):
        try:
            client_uuid = event.client.uuid
            db_list = self._generate_camera_list()
            self.fireEvent(send(client_uuid, {
                'component': 'hfos.camera.manager',
                'action': 'list',
                'data': db_list
            }), "hfosweb")
        except Exception as e:
            self.log("Listing error: ", e, type(e), lvl=error)

    @handler(camera_subscribe, channel='hfosweb')
    def camera_subscribe(self, event):
        # TODO: Verify everything and send response
        try:
            data = event.data
            client_uuid = event.client.uuid
            if data in self._subscribers:
                if client_uuid not in self._subscribers[data]:
                    self._subscribers[data].append(client_uuid)
            else:
                self._subscribers[data] = [client_uuid]
            self.log("Subscription registered: ", data, client_uuid)
            return
        except Exception as e:
            self.log("Subscription Error:", e, type(e), lvl=error)

    @handler(camera_unsubscribe, channel='hfosweb')
    def camera_unsubscribe(self, event):
        try:
            client_uuid = event.client.uuid
            data = event.data
            self._unsubscribe(client_uuid, data)
            return
        except Exception as e:
            self.log("Global Error: '%s' %s" % (e, type(e)), lvl=error)
